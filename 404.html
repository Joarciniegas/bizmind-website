<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>404 - Anomaly Detected | BizMind AI Agency</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #00f0ff;
            --secondary: #7c3aed;
            --accent: #ff00ff;
            --dark: #030014;
            --gradient-1: linear-gradient(135deg, #00f0ff 0%, #7c3aed 50%, #ff00ff 100%);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: #030014;
            color: #fff;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        /* === BACKGROUND LAYER WITH LIGHTNING (ReactBits-style WebGL) === */
        .bg-container {
            position: fixed;
            inset: 0;
            z-index: 0;
            overflow: hidden;
        }

        #lightning-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Optional cyber grid overlay to keep your ‚ÄúBizMind‚Äù vibe */
        .grid-pattern {
            position: absolute;
            inset: 0;
            background-image:
                linear-gradient(rgba(0, 240, 255, 0.06) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 240, 255, 0.06) 1px, transparent 1px);
            background-size: 52px 52px;
            opacity: 0.5;
            mix-blend-mode: soft-light;
            pointer-events: none;
        }

        /* Soft cyber glows using your colors */
        .glow-orb {
            position: absolute;
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0.85;
            mix-blend-mode: screen;
            pointer-events: none;
        }

        .orb-1 {
            width: 620px;
            height: 620px;
            background: radial-gradient(circle, rgba(124, 58, 237, 0.6), transparent 60%);
            top: -240px;
            right: -220px;
        }

        .orb-2 {
            width: 540px;
            height: 540px;
            background: radial-gradient(circle, rgba(255, 0, 255, 0.5), transparent 60%);
            bottom: -220px;
            left: -200px;
        }

        .orb-3 {
            width: 360px;
            height: 360px;
            background: radial-gradient(circle, rgba(0, 240, 255, 0.55), transparent 60%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.7;
        }

        /* === CONTENT === */
        .content {
            position: relative;
            z-index: 2;
            text-align: center;
            padding: 40px 24px;
            max-width: 720px;
        }

        .eyebrow {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 6px 14px;
            border-radius: 999px;
            border: 1px solid rgba(0, 240, 255, 0.5);
            background: radial-gradient(circle at 0 0, rgba(0, 240, 255, 0.16), transparent 65%);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 18px;
        }

        .eyebrow-dot {
            width: 7px;
            height: 7px;
            border-radius: 999px;
            background: var(--primary);
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.9);
        }

        .error-code {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(5rem, 16vw, 9rem);
            font-weight: 900;
            line-height: 0.9;
            margin-bottom: 20px;
            background: var(--gradient-1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 0.08em;
            position: relative;
            text-shadow:
                0 0 18px rgba(0, 240, 255, 0.4),
                0 0 32px rgba(255, 0, 255, 0.35);
            animation: glitch-flicker 3.6s infinite alternate;
        }

        /* Ligero efecto glitch/flicker en el 404 */
        .error-code::before,
        .error-code::after {
            content: "404";
            position: absolute;
            inset: 0;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            mix-blend-mode: screen;
            opacity: 0.55;
            pointer-events: none;
        }

        .error-code::before {
            transform: translate(2px, 0);
            text-shadow: -2px 0 var(--primary);
            clip-path: polygon(0 0, 100% 0, 100% 46%, 0 52%);
        }

        .error-code::after {
            transform: translate(-3px, 1px);
            text-shadow: 2px 0 var(--accent);
            clip-path: polygon(0 54%, 100% 48%, 100% 100%, 0 100%);
        }

        @keyframes glitch-flicker {
            0% {
                opacity: 0.8;
                transform: translateY(0);
            }
            5% {
                opacity: 0.35;
                transform: translateY(1px) skewX(-2deg);
            }
            9% {
                opacity: 1;
                transform: translateY(-1px);
            }
            15% {
                opacity: 0.7;
                transform: translateX(1px);
            }
            25% {
                opacity: 1;
                transform: translateX(0);
            }
            45% {
                opacity: 0.9;
            }
            52% {
                opacity: 0.4;
                transform: translateY(1px) skewX(1deg);
            }
            60%,
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1.8rem, 4vw, 2.4rem);
            margin-bottom: 14px;
        }

        p {
            font-size: 1.05rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 24px;
        }

        .subcopy {
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.5);
            max-width: 520px;
            margin: 0 auto 40px;
        }

        .btn-row {
            display: flex;
            gap: 16px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 13px 30px;
            background: rgba(3, 0, 20, 0.7);
            border: 1px solid rgba(0, 240, 255, 0.8);
            color: var(--primary);
            text-decoration: none;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.98rem;
            font-weight: 600;
            border-radius: 999px;
            transition: all 0.25s ease-out;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 0 0, rgba(0, 240, 255, 0.25), transparent 60%);
            opacity: 0;
            transition: opacity 0.25s ease-out;
        }

        .btn span {
            position: relative;
            z-index: 1;
        }

        .btn:hover {
            color: #030014;
            border-color: transparent;
            background: var(--gradient-1);
            box-shadow:
                0 0 18px rgba(0, 240, 255, 0.6),
                0 0 26px rgba(255, 0, 255, 0.45);
            transform: translateY(-1px);
        }

        .btn:hover::before {
            opacity: 1;
        }

        .btn-secondary {
            border-color: rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.8);
            background: rgba(3, 0, 20, 0.8);
        }

        .btn-secondary:hover {
            background: radial-gradient(circle at 80% 0, rgba(255, 0, 255, 0.35), transparent 60%);
            border-color: rgba(255, 0, 255, 0.7);
            color: #ffffff;
        }

        @media (max-width: 768px) {
            .content {
                padding: 32px 18px;
            }
            .subcopy {
                margin-bottom: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="bg-container">
        <!-- WebGL lightning background -->
        <canvas id="lightning-canvas"></canvas>

        <!-- Cyber overlays with your colors -->
        <div class="glow-orb orb-1"></div>
        <div class="glow-orb orb-2"></div>
        <div class="glow-orb orb-3"></div>
        <div class="grid-pattern"></div>
    </div>

    <div class="content">
        <div class="eyebrow">
            <span class="eyebrow-dot"></span>
            <span>BizMind Neural Network // 404 Anomaly</span>
        </div>

        <div class="error-code">404</div>

        <h1>Signal Lost in the Synthetic Mind</h1>
        <p>
            Our AI just scanned this route across millions of timelines.<br>
            In every single one of them, this page does not exist‚Ä¶ yet.
        </p>
        <p class="subcopy">
            If you didn‚Äôt expect to be here, you‚Äôve just found a blind spot in the system.<br>
            <strong>Humans call it ‚Äú404‚Äù.</strong> Our models call it <em>‚Äúa glitch worth investigating‚Äù</em>.
        </p>

        <div class="btn-row">
            <a href="/" class="btn">
                <span>üè† Return to main simulation</span>
            </a>
            <a href="/#contact" class="btn btn-secondary">
                <span>ü§ñ Tell our AI team what you were looking for</span>
            </a>
        </div>
    </div>

    <script>
        // WebGL lightning background based on ReactBits Lightning, adapted to plain JS
        (function () {
            const canvas = document.getElementById('lightning-canvas');
            if (!canvas) return;

            const gl = canvas.getContext('webgl');
            if (!gl) {
                console.error('WebGL not supported');
                return;
            }

            const resizeCanvas = () => {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                gl.viewport(0, 0, canvas.width, canvas.height);
            };

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            const vertexShaderSource = `
                attribute vec2 aPosition;
                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);
                }
            `;

            const fragmentShaderSource = `
                precision mediump float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform float uHue;
                uniform float uXOffset;
                uniform float uSpeed;
                uniform float uIntensity;
                uniform float uSize;
                
                #define OCTAVE_COUNT 10

                vec3 hsv2rgb(vec3 c) {
                    vec3 rgb = clamp(
                        abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0,
                        0.0,
                        1.0
                    );
                    return c.z * mix(vec3(1.0), rgb, c.y);
                }

                float hash11(float p) {
                    p = fract(p * .1031);
                    p *= p + 33.33;
                    p *= p + p;
                    return fract(p);
                }

                float hash12(vec2 p) {
                    vec3 p3 = fract(vec3(p.xyx) * .1031);
                    p3 += dot(p3, p3.yzx + 33.33);
                    return fract((p3.x + p3.y) * p3.z);
                }

                mat2 rotate2d(float theta) {
                    float c = cos(theta);
                    float s = sin(theta);
                    return mat2(c, -s, s, c);
                }

                float noise(vec2 p) {
                    vec2 ip = floor(p);
                    vec2 fp = fract(p);
                    float a = hash12(ip);
                    float b = hash12(ip + vec2(1.0, 0.0));
                    float c = hash12(ip + vec2(0.0, 1.0));
                    float d = hash12(ip + vec2(1.0, 1.0));
                    
                    vec2 t = smoothstep(0.0, 1.0, fp);
                    return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);
                }

                float fbm(vec2 p) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    for (int i = 0; i < OCTAVE_COUNT; ++i) {
                        value += amplitude * noise(p);
                        p *= rotate2d(0.45);
                        p *= 2.0;
                        amplitude *= 0.5;
                    }
                    return value;
                }

                void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
                    vec2 uv = fragCoord / iResolution.xy;
                    uv = 2.0 * uv - 1.0;
                    uv.x *= iResolution.x / iResolution.y;
                    uv.x += uXOffset;
                    
                    uv += 2.0 * fbm(uv * uSize + 0.8 * iTime * uSpeed) - 1.0;
                    
                    float dist = abs(uv.x);
                    vec3 baseColor = hsv2rgb(vec3(uHue / 360.0, 0.7, 0.9));
                    vec3 col = baseColor * pow(mix(0.0, 0.09, hash11(iTime * uSpeed)) / dist, 1.0) * uIntensity;
                    col = pow(col, vec3(1.0));
                    fragColor = vec4(col, 1.0);
                }

                void main() {
                    mainImage(gl_FragColor, gl_FragCoord.xy);
                }
            `;

            function compileShader(source, type) {
                const shader = gl.createShader(type);
                if (!shader) return null;
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
            if (!vertexShader || !fragmentShader) return;

            const program = gl.createProgram();
            if (!program) return;
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return;
            }
            gl.useProgram(program);

            const vertices = new Float32Array([
                -1, -1,
                 1, -1,
                -1,  1,
                -1,  1,
                 1, -1,
                 1,  1
            ]);
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const aPosition = gl.getAttribLocation(program, 'aPosition');
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

            const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');
            const iTimeLocation = gl.getUniformLocation(program, 'iTime');
            const uHueLocation = gl.getUniformLocation(program, 'uHue');
            const uXOffsetLocation = gl.getUniformLocation(program, 'uXOffset');
            const uSpeedLocation = gl.getUniformLocation(program, 'uSpeed');
            const uIntensityLocation = gl.getUniformLocation(program, 'uIntensity');
            const uSizeLocation = gl.getUniformLocation(program, 'uSize');

            const startTime = performance.now();

            function render() {
                const now = performance.now();
                const t = (now - startTime) / 1000.0;

                gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
                gl.uniform1f(iTimeLocation, t);

                // Ajusta estos valores para tu ‚Äúcyberpink‚Äù:
                gl.uniform1f(uHueLocation, 285.0);     // 220 = azul, 285 ‚âà morado/rosa
                gl.uniform1f(uXOffsetLocation, 0.0);   // desplazar el rayo horizontal
                gl.uniform1f(uSpeedLocation, 1.0);     // velocidad
                gl.uniform1f(uIntensityLocation, 1.2); // brillo
                gl.uniform1f(uSizeLocation, 1.0);      // tama√±o del patr√≥n

                gl.drawArrays(gl.TRIANGLES, 0, 6);
                requestAnimationFrame(render);
            }

            requestAnimationFrame(render);
        })();
    </script>
</body>
</html>
